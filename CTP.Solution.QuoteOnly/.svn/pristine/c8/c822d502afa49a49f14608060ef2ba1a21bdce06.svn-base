using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using System.Xml.Linq;
using CTP;
using log4net;
using MathNet.Numerics;
using MathNet.Numerics.LinearAlgebra.Double;

namespace WrapperTest
{
    public enum ChannelType
    {
        模拟24X7,
        模拟交易所,
        华泰期货,
        宏源期货
    }

    public static class MathUtils
    {
        /// <summary>
        /// 直线的斜率要求
        /// </summary>
        public static double Slope = 0.1;

        /// <summary>
        /// 根据连续几个行情，判断最近的趋势是不是向上，排除太平的，要求大于tan15度
        /// </summary>
        /// <param name="xdata"></param>
        /// <param name="ydata"></param>
        /// <returns></returns>
        public static bool IsPointingUp(List<double> xdata, List<double> ydata)
        {
            var line = Fit.Line(xdata.ToArray(), ydata.ToArray());
            return line.Item2 > Math.Tan(Slope / 180.0 * Math.PI);
        }

        /// <summary>
        /// 根据连续几个行情，判断最近的趋势是不是向下，排除太平的，要求大于tan15度
        /// </summary>
        /// <param name="xdata"></param>
        /// <param name="ydata"></param>
        /// <returns></returns>
        public static bool IsPointingDown(List<double> xdata, List<double> ydata)
        {
            var line = Fit.Line(xdata.ToArray(), ydata.ToArray());
            return line.Item2 < Math.Tan(-Slope / 180.0 * Math.PI);
        }
    }

    public static class Utils
    {
        public static ILog LogDebug;
        public static ILog LogInfo;
        public static ConcurrentDictionary<string, ILog> LogQuotes;
        public static ConcurrentDictionary<string, ILog> LogMinuteQuotes;

        public static readonly string AssemblyPath = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location) +
                                                     "\\";

        public static bool IsMailingEnabled;
        public static bool IsInitialized = false;
        public static double GoUpRangeComparedToPreClosePrice = 1.01;
        public static double FallDownRangeComparedToPreClosePrice = 0.99;
        public static double GoUpRangeComparedToLowestPrice = 1.005;

        /// <summary>
        /// 开仓时沿均线的误差值
        /// </summary>
        public static double OpenTolerance = 0.0003;

        /// <summary>
        /// 止损平仓时，最新价偏离成本价的幅度限制
        /// </summary>
        public static double CloseTolerance = 0.01;

        /// <summary>
        /// 从最高距离跌落的幅度限制，用于止损
        /// </summary>
        public static double FallLimitFromHighestDistance = 0.003;

        /// <summary>
        /// 当最高距离为最新价的某个幅度时，才考虑这种止损，避免多次小止损
        /// </summary>
        public static double HighestDistanceConsiderLimit = 0.004;

        public static double InstrumentTotalPrice = 40000;

        public static double FallDonwRangeComparedToHighestPrice = 0.995;

        public static double StopLossUpperRange = 1.005;
        public static double StopLossLowerRange = 0.995;
        public static double LimitCloseRange = 0.995;
        public static int OpenVolumePerTime = 1;
        public static int CategoryUpperLimit = 8;

        /// <summary>
        /// 用于拟合的行情数量之一，短
        /// </summary>
        public static int ShortQueueSize = 300;

        /// <summary>
        /// 用于拟合的行情数量之一，长
        /// </summary>
        public static int LongQueueSize = 1000;

        /// <summary>
        /// 用于拟合的分时图节点个数
        /// </summary>
        public static int MinuteByMinuteSize = 10;

        public static List<string> AllowedCategories = new List<string>();
        public static ChannelType CurrentChannel = ChannelType.模拟交易所;
        public static int ExchangeTimeOffset = 0;
        public static List<double> ShortXData;
        public static List<double> LongXData;
        public static List<double> MinuteXData;

        public static void GetLoggers()
        {
            LogDebug = LogManager.GetLogger("logDebug");
            LogInfo = LogManager.GetLogger("logInfo");

            LogQuotes = new ConcurrentDictionary<string, ILog>();
            LogMinuteQuotes = new ConcurrentDictionary<string, ILog>();

            foreach (var category in AllowedCategories)
            {
                var log = LogManager.GetLogger(category);
                LogQuotes[category] = log;

                var logMinute = LogManager.GetLogger(category + "Minute");
                LogMinuteQuotes[category] = logMinute;
            }

            ShortXData = new List<double>();

            for (var i = 0; i < ShortQueueSize; i++)
            {
                ShortXData.Add(i);
            }

            LongXData = new List<double>();

            for (var i = 0; i < LongQueueSize; i++)
            {
                LongXData.Add(i);
            }

            MinuteXData = new List<double>();

            for (var i = 0; i < MinuteByMinuteSize; i++)
            {
                MinuteXData.Add(i);
            }
        }

        public static string GetInstrumentCategory(string instrumentId)
        {
            var regex = new Regex("^[a-zA-Z]+");
            var match = regex.Match(instrumentId);

            if (match.Success)
            {
                Debug.Assert(match.Value.Length <= 2);
                return match.Value;
            }

            return null;
        }

        public static void Enqueue(
            ref ConcurrentDictionary<string, Queue<ThostFtdcDepthMarketDataField>> instrumentToQuoteQueue,
            ThostFtdcDepthMarketDataField preQuote, string instrumentId, int queueSize)
        {
            if (!instrumentToQuoteQueue.ContainsKey(instrumentId))
            {
                instrumentToQuoteQueue[instrumentId] = new Queue<ThostFtdcDepthMarketDataField>();
            }

            if (instrumentToQuoteQueue[instrumentId].Count == queueSize)
            {
                instrumentToQuoteQueue[instrumentId].Dequeue();
            }

            instrumentToQuoteQueue[instrumentId].Enqueue(preQuote);
        }

        public static string GetHourAndMinute(string time)
        {
            //21:09:00
            return time.Substring(0, 5);
        }

        public static string FormatQuote(ThostFtdcDepthMarketDataField pDepthMarketData)
        {
            var s =
                string.Format(
                    "合约:{0},最新价:{1},开盘价:{2},昨结价:{3},昨收价:{4},最高价:{5},最低价:{6},涨停价:{7},跌停价:{8},更新时间:{9},毫秒数:{10},平均价:{11},最新价与平均价距离:{12},成交量:{13},交易日:{14}",
                    pDepthMarketData.InstrumentID, pDepthMarketData.LastPrice, pDepthMarketData.OpenPrice,
                    pDepthMarketData.PreSettlementPrice,
                    pDepthMarketData.PreClosePrice, pDepthMarketData.HighestPrice, pDepthMarketData.LowestPrice,
                    pDepthMarketData.UpperLimitPrice, pDepthMarketData.LowerLimitPrice, pDepthMarketData.UpdateTime,
                    pDepthMarketData.UpdateMillisec,
                    GetAveragePrice(pDepthMarketData), pDepthMarketData.LastPrice - GetAveragePrice(pDepthMarketData),
                    pDepthMarketData.Volume, pDepthMarketData.TradingDay);

            return s;
        }

        public static void WriteQuote(ThostFtdcDepthMarketDataField pDepthMarketData)
        {
            var instrumentId = pDepthMarketData.InstrumentID;

            //保存前几个行情
            if (InstrumentToLatestQuote.ContainsKey(instrumentId))
            {
                var preQuote = InstrumentToLatestQuote[instrumentId];

                Enqueue(ref InstrumentToPreLatestQuoteShort, preQuote, instrumentId, ShortQueueSize);
                Enqueue(ref InstrumentToPreLatestQuoteLong, preQuote, instrumentId, LongQueueSize); 
                
                if (!InstrumentToMinuteByMinuteChart.ContainsKey(instrumentId))
                {
                    InstrumentToMinuteByMinuteChart[instrumentId] = new ConcurrentDictionary<string, double>();
                }

                var minuteByMinuteChart = InstrumentToMinuteByMinuteChart[instrumentId];
                minuteByMinuteChart[GetHourAndMinute(pDepthMarketData.UpdateTime)] = pDepthMarketData.LastPrice;

                //到下一分钟之前，记录当前分钟的最后一个行情，作为分时图节点
                if (GetHourAndMinute(preQuote.UpdateTime) != GetHourAndMinute(pDepthMarketData.UpdateTime))
                {
                    LogMinuteQuotes[GetInstrumentCategory(pDepthMarketData.InstrumentID)].Debug(FormatQuote(preQuote));
                }
            }

            //保存当前行情
            InstrumentToLatestQuote[pDepthMarketData.InstrumentID] = pDepthMarketData;

            var s = FormatQuote(pDepthMarketData);

            try
            {
                LogQuotes[GetInstrumentCategory(pDepthMarketData.InstrumentID)].Debug(s);
            }
            catch (Exception)
            {

            }

            Console.WriteLine(s);
        }

        public static double GetAveragePrice(ThostFtdcDepthMarketDataField data)
        {
            return data.AveragePrice/data.PreClosePrice < 2
                ? data.AveragePrice
                : InstrumentToInstrumentInfo.ContainsKey(data.InstrumentID)
                    ? data.AveragePrice/InstrumentToInstrumentInfo[data.InstrumentID].VolumeMultiple
                    : data.AveragePrice;
        }

        public static void WriteLine(string line = "\n", bool writeInfo = false)
        {
            LogDebug.Debug(line);
            if (writeInfo)
            {
                LogInfo.Debug(line);
            }
            Console.WriteLine(line);
        }

        public static void OutputLine()
        {
            WriteLine("********************************************************");
        }

        public static string OutputField(object obj, bool outputToFile = true, bool writeInfo = false)
        {
            var sb = new StringBuilder();

            if (outputToFile)
            {
                WriteLine("\n", writeInfo);
                OutputLine();
            }

            var type = obj.GetType();
            var fields = type.GetFields();

            foreach (var field in fields)
            {
                var temp = string.Format("[{0}]:[{1}]", field.Name, field.GetValue(obj));

                if (outputToFile)
                {
                    WriteLine(temp, writeInfo);
                }

                sb.AppendLine(temp);
            }

            if (outputToFile)
            {
                OutputLine();
                WriteLine("\n", writeInfo);
            }

            return sb.ToString();
        }

        public static bool IsWrongRspInfo(ThostFtdcRspInfoField pRspInfo)
        {
            return pRspInfo != null && pRspInfo.ErrorID != 0;
        }

        public static void ReportError(ThostFtdcRspInfoField pRspInfo, string title)
        {
            if (IsWrongRspInfo(pRspInfo))
            {
                WriteLine(string.Format("{0}:{1}", title, pRspInfo.ErrorMsg), true);
            }
        }


        public static bool IsCorrectRspInfo(ThostFtdcRspInfoField pRspInfo)
        {
            return pRspInfo != null && pRspInfo.ErrorID == 0;
        }

        public static void ReadConfig()
        {
            var configFile = AssemblyPath + "config.ini";

            if (File.Exists(configFile))
            {
                var sr = new StreamReader(configFile, Encoding.UTF8);

                var line = sr.ReadLine();

                var s = GetLineData(line).Split(new[] {";"}, StringSplitOptions.RemoveEmptyEntries);
                AllowedCategories.AddRange(s.Where(t => !string.IsNullOrWhiteSpace(t)));

                line = sr.ReadLine();

                GoUpRangeComparedToPreClosePrice = 1 + Convert.ToDouble(GetLineData(line));
                FallDownRangeComparedToPreClosePrice = 1 - Convert.ToDouble(GetLineData(line));

                line = sr.ReadLine();

                GoUpRangeComparedToLowestPrice = 1 + Convert.ToDouble(GetLineData(line));
                FallDonwRangeComparedToHighestPrice = 1 - Convert.ToDouble(GetLineData(line));

                line = sr.ReadLine();
                StopLossUpperRange = 1 + Convert.ToDouble(GetLineData(line));
                StopLossLowerRange = 1 - Convert.ToDouble(GetLineData(line));

                line = sr.ReadLine();
                LimitCloseRange = 1 - Convert.ToDouble(GetLineData(line));

                line = sr.ReadLine();
                OpenVolumePerTime = Convert.ToInt32(GetLineData(line));

                line = sr.ReadLine();
                CategoryUpperLimit = Convert.ToInt32(GetLineData(line));

                line = sr.ReadLine();
                OpenTolerance = Convert.ToDouble(GetLineData(line));

                line = sr.ReadLine();
                CloseTolerance = Convert.ToDouble(GetLineData(line));

                line = sr.ReadLine();
                FallLimitFromHighestDistance = Convert.ToDouble(GetLineData(line));

                line = sr.ReadLine();
                ShortQueueSize = Convert.ToInt32(GetLineData(line));

                line = sr.ReadLine();
                LongQueueSize = Convert.ToInt32(GetLineData(line));

                line = sr.ReadLine();
                HighestDistanceConsiderLimit = Convert.ToDouble(GetLineData(line));

                line = sr.ReadLine();
                InstrumentTotalPrice = Convert.ToDouble(GetLineData(line));

                line = sr.ReadLine();
                MinuteByMinuteSize = Convert.ToInt32(GetLineData(line));

                line = sr.ReadLine();
                MathUtils.Slope = Convert.ToDouble(GetLineData(line));
                sr.Close();
            }
        }

        public static string GetLineData(string line)
        {
            var s = line.Split(new[] {'#'}, StringSplitOptions.RemoveEmptyEntries);

            if (s.Length > 0)
            {
                return s[0];
            }

            return null;
        }

        public static string GetPositionKey(string instrumentId, EnumPosiDirectionType direction,
            EnumPositionDateType positionDate)
        {
            return string.Format("{0}:{1}:{2}", instrumentId, direction, positionDate);
        }

        public static string GetInstrumentIdFromPositionKey(string positionKey)
        {
            var s = positionKey.Split(new[] {':'}, StringSplitOptions.RemoveEmptyEntries);
            return s[0];
        }

        /// <summary>
        /// 判断该合约是不是允许交易的品种以及是不是主力合约
        /// </summary>
        /// <param name="instrumentId"></param>
        /// <returns></returns>
        public static bool IsTradableInstrument(string instrumentId)
        {
            if (CategoryToMainInstrument.ContainsKey(GetInstrumentCategory(instrumentId)))
            {
                var v = CategoryToMainInstrument[GetInstrumentCategory(instrumentId)];

                if (v.Equals(instrumentId))
                {
                    return true;
                }
            }

            return false;
        }

        /// <summary>
        /// 判断当前时间是否在合约的交易时间之内
        /// </summary>
        /// <param name="instrumentId"></param>
        /// <returns></returns>
        public static bool IsInInstrumentTradingTime(string instrumentId)
        {
            if (CurrentChannel == ChannelType.模拟24X7)
            {
                return true;
            }

            var category = GetInstrumentCategory(instrumentId);

            if (CategoryToExchangeId.ContainsKey(category))
            {
                return ExchangeTime.Instance.IsTradingTime(category, CategoryToExchangeId[category]);
            }

            return false;
        }

        /// <summary>
        /// 判断合约是否有未完成的报单
        /// </summary>
        /// <param name="instrumentId"></param>
        /// <returns></returns>
        public static bool IsUnFinishedOrderExisting(string instrumentId, EnumDirectionType direction,
            EnumOffsetFlagType openOrClose)
        {
            if (
                OrderRefToUnFinishedOrders.Values.Any(
                    s =>
                        s.InstrumentID.Equals(instrumentId) && s.Direction == direction &&
                        s.CombOffsetFlag_0 == openOrClose)) //该合约还有未完成的同方向报单，不报单
            {
                return true;
            }

            return false;
        }

        /// <summary>
        /// 判断合约是不是上期所的合约
        /// </summary>
        /// <param name="instrumentId"></param>
        /// <returns></returns>
        public static bool IsShfeInstrument(string instrumentId)
        {
            var category = GetInstrumentCategory(instrumentId);

            if (CategoryToExchangeId.ContainsKey(category))
            {
                return CategoryToExchangeId[category].Equals("SHFE");
            }

            return false;
        }

        public static StopLossPrices CreateStopLossPrices(ThostFtdcDepthMarketDataField pDepthMarketData)
        {
            //新交易日未开盘时，最高价和最低价为无效值，要排除；交易日中途启动时，暂时设最高价最低价，其实应该读取上次的参考价。
            var stopLossPrices = new StopLossPrices();

            if (pDepthMarketData.HighestPrice > 1 && pDepthMarketData.LowestPrice > 1)
            {
                stopLossPrices.ForLong = pDepthMarketData.HighestPrice;
                stopLossPrices.ForShort = pDepthMarketData.LowestPrice;
            }
            else
            {
                stopLossPrices.ForLong = pDepthMarketData.PreClosePrice;
                stopLossPrices.ForShort = pDepthMarketData.PreClosePrice;
            }

            return stopLossPrices;
        }

        public static bool IsInstrumentLocked(string instrumentId)
        {
            if (LockedInstruments.ContainsKey(instrumentId))
            {
                WriteLine(string.Format("合约{0}还有报单在途中，不报单", instrumentId), true);
                return true;
            }

            return false;
        }

        /// <summary>
        /// 锁定正在开仓的合约
        /// </summary>
        /// <param name="instrumentId"></param>
        public static void LockOpenInstrument(string instrumentId)
        {
            LockedOpenInstruments[instrumentId] = instrumentId;
            WriteLine(string.Format("增加开仓在途记录{0}", instrumentId), true);
        }

        public static void RemoveLockedOpenInstrument(string instrumentId)
        {
            if (LockedOpenInstruments.ContainsKey(instrumentId))
            {
                string temp;
                LockedOpenInstruments.TryRemove(instrumentId, out temp);
                WriteLine(string.Format("减少开仓在途记录{0}", instrumentId), true);
            }
        }

        /// <summary>
        /// 锁定正在报单的合约
        /// </summary>
        /// <param name="instrumentId"></param>
        public static void LockInstrument(string instrumentId)
        {
            LockedInstruments[instrumentId] = instrumentId;
            WriteLine(string.Format("锁定{0}", instrumentId), true);
        }

        public static void RemoveLockedInstrument(string instrumentId)
        {
            if (LockedInstruments.ContainsKey(instrumentId))
            {
                string temp;
                LockedInstruments.TryRemove(instrumentId, out temp);
                WriteLine(string.Format("解锁{0}", instrumentId), true);
            }
        }

        public static void UnlockInstrument(string instrumentId, EnumOffsetFlagType flag)
        {
            if (flag == EnumOffsetFlagType.Open)
            {
                RemoveLockedOpenInstrument(instrumentId);
            }

            RemoveLockedInstrument(instrumentId);
        }

        /// <summary>
        /// 读取止损参考价
        /// </summary>
        public static void ReadStopLossPrices()
        {
            var file = string.Format("{0}_StopLossPrices.txt", CurrentChannel);

            if (File.Exists(file))
            {
                var sr = new StreamReader(file, Encoding.UTF8);
                string line;

                while ((line = sr.ReadLine()) != null)
                {
                    var s = line.Split(new[] {":"}, StringSplitOptions.RemoveEmptyEntries);

                    if (s.Length > 3)
                    {
                        double costLong;
                        double costShort;
                        double forLong;
                        double forShort;

                        try
                        {
                            costLong = Convert.ToDouble(s[1]);
                        }
                        catch (Exception)
                        {
                            costLong = 0;
                        }

                        try
                        {
                            costShort = Convert.ToDouble(s[2]);
                        }
                        catch (Exception)
                        {
                            costShort = 0;
                        }

                        try
                        {
                            forLong = Convert.ToDouble(s[3]);
                        }
                        catch (Exception)
                        {
                            forLong = 0;
                        }

                        try
                        {
                            forShort = Convert.ToDouble(s[4]);
                        }
                        catch (Exception)
                        {
                            forShort = 0;
                        }

                        var stopLossPrices = new StopLossPrices
                        {
                            CostLong = costLong,
                            CostShort = costShort,
                            ForLong = forLong,
                            ForShort = forShort
                        };
                        InstrumentToStopLossPrices[s[0]] = stopLossPrices;
                    }
                }

                sr.Close();
            }
        }


        /// <summary>
        /// 保存止损参考价
        /// </summary>
        public static void SaveStopLossPricesAndInstrumentTotalPrices()
        {
            //保存止损价
            if (InstrumentToStopLossPrices.Count > 0)
            {
                var sw = new StreamWriter(string.Format("{0}_StopLossPrices.txt", CurrentChannel), false, Encoding.UTF8);
                foreach (var kv in InstrumentToStopLossPrices)
                {
                    sw.WriteLine("{0}:{1}:{2}:{3}:{4}", kv.Key, kv.Value.CostLong, kv.Value.CostShort, kv.Value.ForLong,
                        kv.Value.ForShort);
                }
                sw.Close();
            }

            //保存一手合约的当前总价
            if (CategoryToMainInstrument.Count > 0)
            {
                var sw = new StreamWriter(string.Format("{0}_InstrumentPrices.txt", CurrentChannel), false,
                    Encoding.UTF8);
                foreach (var kv in CategoryToMainInstrument)
                {
                    if (InstrumentToInstrumentInfo.ContainsKey(kv.Value) &&
                        InstrumentToLatestQuote.ContainsKey(kv.Value))
                    {
                        var instrumentInfo = InstrumentToInstrumentInfo[kv.Value];
                        var quote = InstrumentToLatestQuote[kv.Value];
                        var totalPrice = instrumentInfo.VolumeMultiple*quote.LastPrice;
                        InstrumentToTotalPrice[kv.Value] = totalPrice;
                        sw.WriteLine("{0}:{1}:{2}", kv.Key, kv.Value, totalPrice);
                    }
                }
                sw.Close();
            }
        }

        public static ConcurrentDictionary<string, double> InstrumentToTotalPrice =
            new ConcurrentDictionary<string, double>();

        public static ConcurrentDictionary<string, ThostFtdcDepthMarketDataField> InstrumentToLatestQuote =
            new ConcurrentDictionary<string, ThostFtdcDepthMarketDataField>();

        public static ConcurrentDictionary<string, Queue<ThostFtdcDepthMarketDataField>> InstrumentToPreLatestQuoteShort
            =
            new ConcurrentDictionary<string, Queue<ThostFtdcDepthMarketDataField>>();

        public static ConcurrentDictionary<string, Queue<ThostFtdcDepthMarketDataField>> InstrumentToPreLatestQuoteLong
            = new ConcurrentDictionary<string, Queue<ThostFtdcDepthMarketDataField>>();

        public static ConcurrentDictionary<string, ThostFtdcInstrumentField> InstrumentToInstrumentInfo =
            new ConcurrentDictionary<string, ThostFtdcInstrumentField>();

        public static ConcurrentDictionary<string, List<ThostFtdcDepthMarketDataField>>
            InstrumentToInstrumentsDepthMarketData =
                new ConcurrentDictionary<string, List<ThostFtdcDepthMarketDataField>>();

        public static ConcurrentDictionary<string, string> CategoryToMainInstrument =
            new ConcurrentDictionary<string, string>();

        public static ConcurrentDictionary<string, string> CategoryToExchangeId =
            new ConcurrentDictionary<string, string>();

        public static ConcurrentDictionary<string, ThostFtdcOrderField> OrderRefToUnFinishedOrders =
            new ConcurrentDictionary<string, ThostFtdcOrderField>();

        /// <summary>
        /// 合约的止损参考价，分为多仓和空仓的成本价，多仓和空仓的止损参考价
        /// </summary>
        public static ConcurrentDictionary<string, StopLossPrices> InstrumentToStopLossPrices =
            new ConcurrentDictionary<string, StopLossPrices>();

        /// <summary>
        /// 还未收到报单响应的合约，暂时不能报单
        /// </summary>
        public static ConcurrentDictionary<string, string> LockedInstruments =
            new ConcurrentDictionary<string, string>();

        /// <summary>
        /// 记录开仓在途的合约，防止开仓超过品种数量限制
        /// </summary>
        public static ConcurrentDictionary<string, string> LockedOpenInstruments =
            new ConcurrentDictionary<string, string>();

        /// <summary>
        /// 合约的开仓次数记录，如果超过，不再开仓
        /// </summary>
        public static ConcurrentDictionary<string, int> InstrumentToOpenCount = new ConcurrentDictionary<string, int>();

        /// <summary>
        /// 合约的分时图数据，取每分钟最后一个行情数据
        /// </summary>
        public static ConcurrentDictionary<string, ConcurrentDictionary<string, double>> InstrumentToMinuteByMinuteChart
            = new ConcurrentDictionary<string, ConcurrentDictionary<string, double>>();
    }


    public class ExchangeTime
    {
        private ExchangeTime()
        {
            try
            {
                //无夜盘的品种
                m_sExchsh = "SHFE 9:0:0-10:15:0;10:30:0-11:30:0;13:30:0-15:0:0";
                m_sExchdl = "DCE 9:0:0-10:15:0;10:30:0-11:30:0;13:30:0-15:0:0";
                m_sExchzz = "CZCE 9:0:0-10:15:0;10:30:0-11:30:0;13:30:0-15:0:0";

                //所有的夜盘
                m_sExchzzNight = "RM;FG;MA;SR;TA;ZC;CF; 21:0:0-23:30:0";
                m_sExchdlNight = "i;j;jm;a;m;p;y; 21:0:0-23:30:0";
                m_sExchshNight1 = "ag;au; 21:0:0-23:59:59;0:0:0-2:30:0";
                m_sExchshNight3 = "rb;bu;hc 21:0:0-23:0:0";

                m_mapTradingTime = new Dictionary<string, List<TradingTime>>();
                m_sLog = "交易时间";

                InitDefault();
            }
            catch (Exception ex)
            {
            }
        }

        public static ExchangeTime Instance
        {
            get { return _exchangeTime; }
        }

        // sCate在交易时间段返回true
        public bool IsTradingTime(string category, string exchange)
        {
            var result = true;
            try
            {
                foreach (var kvp in m_mapTradingTime)
                {
                    var s = new List<string>();

                    if (kvp.Key.Contains(";"))
                    {
                        var instrumentIds = kvp.Key.Split(new[] {';'}, StringSplitOptions.RemoveEmptyEntries);
                        s.AddRange(instrumentIds);
                    }

                    if (s.Contains(category) || kvp.Key.Equals(exchange))
                    {
                        var currentDateTime = DateTime.Now;
                        var currentSecond = GetSecFromDateTime(currentDateTime) + Utils.ExchangeTimeOffset;
                        foreach (var time in kvp.Value)
                        {
                            if ((currentSecond >= time.StartSecond) && (currentSecond <= time.EndSecond))
                            {
                                return true;
                            }
                        }
                    }

                    result = false;
                }
            }
            catch (Exception ex)
            {
                return true;
            }

            return result;
        }

        private void ParseFromString(string sLine)
        {
            try
            {
                var sKeyValue = sLine.Split(' ');
                var sKey = sKeyValue[0];
                m_sLog += sKey;

                var sValueString = sKeyValue[1];
                var sValue = sValueString.Split(';');
                foreach (var s in sValue)
                {
                    var s1 = s.Split('-');
                    var dtStart = Convert.ToDateTime(s1[0]);
                    var dtEnd = Convert.ToDateTime(s1[1]);
                    var time = new TradingTime
                    {
                        StartTimeString = dtStart.ToLongTimeString(),
                        EndTimeString = dtEnd.ToLongTimeString(),
                        StartSecond = GetSecFromDateTime(dtStart),
                        EndSecond = GetSecFromDateTime(dtEnd)
                    };
                    if (!m_mapTradingTime.ContainsKey(sKey))
                    {
                        m_mapTradingTime[sKey] = new List<TradingTime>();
                    }
                    m_mapTradingTime[sKey].Add(time);
                    m_sLog += s1[0];
                    m_sLog += s1[1];
                }
            }
            catch (Exception ex)
            {
            }
        }

        public int GetSecFromDateTime(DateTime dt)
        {
            try
            {
                return dt.Hour * 3600 + dt.Minute * 60 + dt.Second;
            }
            catch (Exception ex)
            {
            }
            return 0;
        }

        private void InitDefault()
        {
            try
            {
                if (m_mapTradingTime.Count > 0)
                    m_mapTradingTime.Clear();

                ParseFromString(m_sExchsh);
                ParseFromString(m_sExchdl);
                ParseFromString(m_sExchzz);
                ParseFromString(m_sExchzzNight);
                ParseFromString(m_sExchdlNight);
                ParseFromString(m_sExchshNight1);
                ParseFromString(m_sExchshNight2);
                ParseFromString(m_sExchshNight3);
            }
            catch (Exception ex)
            {
            }
        }

        private static readonly ExchangeTime _exchangeTime = new ExchangeTime();

        private string m_sLog;
        private readonly string m_sExchsh;       // 上海
        private readonly string m_sExchdl;       // 大连
        private readonly string m_sExchzz;       // 郑州

        private readonly string m_sExchzzNight;  // TA;SR;CF;RM;ME;MA夜盘
        private readonly string m_sExchdlNight;  // p;j;a;b;m;y;jm;i夜盘
        private readonly string m_sExchshNight1; // ag;au夜盘
        private string m_sExchshNight2; // cu;al;zn;pb;rb;hc;bu夜盘
        private string m_sExchshNight3; // ru夜盘

        private Dictionary<string, List<TradingTime>> m_mapTradingTime;
    }

    public class TradingTime
    {
        public string StartTimeString;
        public string EndTimeString;
        public int StartSecond;   // 时间段开始时间的秒数
        public int EndSecond;
    }
    public class StopLossPrices
    {
        /// <summary>
        /// 当前多仓的持仓成本价
        /// </summary>
        public double CostLong;

        /// <summary>
        /// 当前空仓的持仓成本价
        /// </summary>
        public double CostShort;

        /// <summary>
        /// 多仓止损参考价
        /// </summary>
        public double ForLong;

        /// <summary>
        /// 空仓止损参考价
        /// </summary>
        public double ForShort;
    }
}
